{"ast":null,"code":"import axios from 'axios';\nconst BASE_URL = 'http://localhost:9090';\nexport default function Submit(url, values, states, setErrors, history, e) {\n  e.preventDefault();\n\n  if (Validation(values, states, setErrors)) {\n    for (var key in states) {\n      states[key] = false;\n    }\n\n    console.log(values);\n    axios.post(BASE_URL + url, values).then(response => {\n      let policies = response.data.split('DTPOLICY:');\n      var dict = {\n        jsonPolicy: \"\",\n        dtPolicy: \"\"\n      };\n      dict.jsonPolicy = policies[0];\n      dict.dtPolicy = policies[1];\n      history.push({\n        pathname: '/ODRLCreator',\n        state: dict\n      });\n    }, error => {\n      console.log(error);\n    });\n  }\n}\n_c = Submit;\n;\nexport function jsonOdrlPolicy(url, values, setPolicy) {\n  axios.post(BASE_URL + url, values, {\n    headers: {\n      // Overwrite Axios's automatically set Content-Type\n      'Content-Type': 'application/json'\n    }\n  }).then(response => {\n    setPolicy(response.data);\n  }, error => {\n    console.log(error);\n  });\n}\n;\n\nfunction Validation(values, states, setErrors) {\n  let temp = {};\n  checkHeader(temp, values);\n  temp.location = states.location ? isValidUrl(values.location) : \"\";\n  temp.system = states.system ? isValidUrl(values.system) : \"\";\n  temp.event = states.event ? isValidUrl(values.event) : \"\";\n  temp.purpose = states.purpose ? notEmpty(values.purpose) : \"\";\n  temp.restrictTimeIntervalStart = states.interval ? isValidDate(values.restrictTimeIntervalStart) : \"\";\n  temp.restrictTimeIntervalEnd = states.interval ? isValidDateInterval(values.restrictTimeIntervalStart, values.restrictTimeIntervalEnd) : \"\";\n  temp.payment = states.payment ? notEmpty(values.payment) : \"\";\n  temp.price = states.payment ? isValidFloat(values.price) : \"\";\n  temp.counter = states.counter ? isValidInt(values.counter) : \"\";\n  temp.time = states.time ? isValidInt(values.time) : \"\";\n  temp.timeUnit = states.time ? notEmpty(values.timeUnit) : \"\";\n  temp.modificator = states.anonymizeInTransit ? notEmpty(values.modificator) : \"\"; //temp.valueToChange = states.anonymizeInTransit? isValidUrl(values.valueToChange):\"\";\n  //temp.fieldToChange = states.anonymizeInTransit? notEmpty(values.fieldToChange):\"\";\n\n  temp.systemDevice = states.logAccess ? isValidUrl(values.systemDevice) : \"\";\n  temp.informedParty = states.informedParty ? notEmpty(values.informedParty) : \"\";\n  temp.encoding = states.encoding ? isValidUrl(values.encoding) : \"\";\n  temp.policy = states.policy ? isValidUrl(values.policy) : \"\";\n  temp.timeAndDate = states.timeDate ? isValidDate(values.timeAndDate) : \"\";\n  temp.specifyBeginTime = states.specifyBeginTime ? isValidDate(values.specifyBeginTime) : \"\";\n  temp.logLevel = states.logLevel ? notEmpty(values.logLevel) : \"\";\n  temp.notificationLevel = states.notificationLevel ? notEmpty(values.notificationLevel) : \"\";\n  temp.artifactState = states.artifactState ? notEmpty(values.artifactState) : \"\";\n  temp.restrictTimeDuration = states.restrictTimeDuration ? notEmpty(values.restrictTimeDuration) : \"\";\n  temp.restrictTimeDurationUnit = states.restrictTimeDuration ? notEmpty(values.restrictTimeDurationUnit) : \"\";\n  setErrors({ ...temp\n  });\n  return Object.values(temp).every(x => x === \"\");\n}\n\n_c2 = Validation;\n;\n\nfunction checkHeader(temp, values) {\n  temp.policyType = notEmpty(values.policyType);\n  temp.target = isValidUrl(values.target); //if (values.policyType === \"Agreement\"|| values.policyType === \"Offer\") {\n  //  temp.provider = isValidUrl(values.provider)\n  //}\n\n  if (values.policyType === \"Agreement\" || values.policyType === \"Request\") {\n    temp.consumer = notEmpty(values.consumer);\n  }\n}\n\nfunction isValidUrl(string) {\n  const error = notEmpty(string);\n  if (error !== \"\") return error;\n\n  try {\n    new URL(string);\n  } catch (_) {\n    return \"This is not a valid URI\";\n  }\n\n  return \"\";\n}\n\nfunction isValidDate(date) {\n  const error = notEmpty(date);\n  if (error !== \"\") return error;\n\n  try {\n    var today = new Date();\n    today.setHours(0, 0, 0, 0);\n\n    if (today <= new Date(date)) {\n      return \"\";\n    } else {\n      return \"The entered date is in the past\";\n    }\n  } catch (_) {\n    return \"This is not a valid date\";\n  }\n}\n\nfunction isValidDateInterval(date1, date2) {\n  const error = notEmpty(date2);\n  if (error !== \"\") return error;\n\n  if (date1 === \"\") {\n    return \"The start date should not be empty\";\n  }\n\n  if (new Date(date1) <= new Date(date2)) {\n    return \"\";\n  } else {\n    return \"The end date should be after the start date\";\n  }\n}\n\nfunction isValidFloat(price) {\n  const error = notEmpty(price);\n  if (error !== \"\") return error;\n\n  if (parseFloat(price) < 0) {\n    return \"Price should be positive\";\n  } else if (parseFloat(price) >= 0) {\n    return \"\";\n  } else {\n    return \"Not a valid number\";\n  }\n}\n\nfunction isValidInt(count) {\n  const error = notEmpty(count);\n  if (error !== \"\") return error;\n\n  if (parseInt(count) < 0) {\n    return \"Count should be positive\";\n  } else if (parseFloat(count) >= 0) {\n    return \"\";\n  } else {\n    return \"Not a valid number\";\n  }\n}\n\nfunction notEmpty(str) {\n  if (str === \"\") {\n    return \"The field should not be empty\";\n  } else {\n    return \"\";\n  }\n}\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"Submit\");\n$RefreshReg$(_c2, \"Validation\");","map":{"version":3,"sources":["C:/Repos/IDS/IESE-IDS/odrl_pap_webservice/src/main/ui/odrl-pap/src/components/backend/Submit.js"],"names":["axios","BASE_URL","Submit","url","values","states","setErrors","history","e","preventDefault","Validation","key","console","log","post","then","response","policies","data","split","dict","jsonPolicy","dtPolicy","push","pathname","state","error","jsonOdrlPolicy","setPolicy","headers","temp","checkHeader","location","isValidUrl","system","event","purpose","notEmpty","restrictTimeIntervalStart","interval","isValidDate","restrictTimeIntervalEnd","isValidDateInterval","payment","price","isValidFloat","counter","isValidInt","time","timeUnit","modificator","anonymizeInTransit","systemDevice","logAccess","informedParty","encoding","policy","timeAndDate","timeDate","specifyBeginTime","logLevel","notificationLevel","artifactState","restrictTimeDuration","restrictTimeDurationUnit","Object","every","x","policyType","target","consumer","string","URL","_","date","today","Date","setHours","date1","date2","parseFloat","count","parseInt","str"],"mappings":"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","sourcesContent":["import axios from 'axios';\r\nconst BASE_URL = 'http://localhost:9090';\r\n\r\nexport default function Submit(url, values, states, setErrors, history ,e) {\r\n  e.preventDefault();\r\n  if (Validation(values, states, setErrors)) {\r\n    for (var key in states) {\r\n      states[key] = false;\r\n  }\r\n  console.log(values)\r\n    axios.post(BASE_URL + url, values)\r\n    .then((response) => {\r\n      let policies = response.data.split('DTPOLICY:');\r\n      var dict = {\r\n        jsonPolicy: \"\",\r\n        dtPolicy: \"\",\r\n      }\r\n      dict.jsonPolicy = policies[0];\r\n      dict.dtPolicy = policies[1];\r\n      history.push({\r\n        pathname: '/ODRLCreator',\r\n        state: dict\r\n      })\r\n    }, (error) => {\r\n      console.log(error);\r\n    })    }\r\n};\r\n\r\nexport function jsonOdrlPolicy(url, values, setPolicy) {\r\n    axios.post(BASE_URL + url, values, {\r\n      headers: {\r\n        // Overwrite Axios's automatically set Content-Type\r\n        'Content-Type': 'application/json'\r\n      }\r\n    })\r\n    .then((response) => {\r\n      setPolicy(response.data)\r\n    }, (error) => {\r\n      console.log(error);\r\n    })\r\n};\r\n\r\nfunction Validation(values, states, setErrors) {\r\n    let temp = {};\r\n    checkHeader(temp, values)\r\n    temp.location = states.location ? isValidUrl(values.location) : \"\";\r\n    temp.system = states.system ? isValidUrl(values.system) : \"\";\r\n    temp.event = states.event ? isValidUrl(values.event) : \"\";\r\n    temp.purpose = states.purpose ? notEmpty(values.purpose) : \"\";\r\n    temp.restrictTimeIntervalStart = states.interval ? isValidDate(values.restrictTimeIntervalStart): \"\";\r\n    temp.restrictTimeIntervalEnd = states.interval ? isValidDateInterval(values.restrictTimeIntervalStart, values.restrictTimeIntervalEnd): \"\";\r\n    temp.payment = states.payment ? notEmpty(values.payment) : \"\";\r\n    temp.price = states.payment ? isValidFloat(values.price): \"\";\r\n    temp.counter = states.counter ? isValidInt(values.counter): \"\";\r\n    temp.time = states.time ? isValidInt(values.time):\"\";\r\n    temp.timeUnit = states.time ? notEmpty(values.timeUnit):\"\";\r\n    temp.modificator = states.anonymizeInTransit? notEmpty(values.modificator):\"\";\r\n    //temp.valueToChange = states.anonymizeInTransit? isValidUrl(values.valueToChange):\"\";\r\n    //temp.fieldToChange = states.anonymizeInTransit? notEmpty(values.fieldToChange):\"\";\r\n    temp.systemDevice = states.logAccess? isValidUrl(values.systemDevice):\"\";\r\n    temp.informedParty = states.informedParty? notEmpty(values.informedParty):\"\";\r\n    temp.encoding = states.encoding? isValidUrl(values.encoding):\"\";\r\n    temp.policy = states.policy? isValidUrl(values.policy):\"\";\r\n    temp.timeAndDate = states.timeDate ? isValidDate(values.timeAndDate):\"\";\r\n    temp.specifyBeginTime = states.specifyBeginTime ? isValidDate(values.specifyBeginTime): \"\";\r\n    temp.logLevel = states.logLevel ? notEmpty(values.logLevel):\"\";\r\n    temp.notificationLevel = states.notificationLevel ? notEmpty(values.notificationLevel):\"\";\r\n    temp.artifactState = states.artifactState ? notEmpty(values.artifactState):\"\";\r\n    temp.restrictTimeDuration = states.restrictTimeDuration? notEmpty(values.restrictTimeDuration):\"\";\r\n    temp.restrictTimeDurationUnit = states.restrictTimeDuration? notEmpty(values.restrictTimeDurationUnit):\"\";\r\n    setErrors({\r\n      ...temp,\r\n    });\r\n    return Object.values(temp).every((x) => x === \"\");\r\n  };\r\n\r\n  function checkHeader(temp, values) {\r\n    temp.policyType = notEmpty(values.policyType)\r\n    temp.target = isValidUrl(values.target)\r\n    //if (values.policyType === \"Agreement\"|| values.policyType === \"Offer\") {\r\n    //  temp.provider = isValidUrl(values.provider)\r\n    //}\r\n    if (values.policyType === \"Agreement\"|| values.policyType === \"Request\") {\r\n      temp.consumer = notEmpty(values.consumer)\r\n    }\r\n  }\r\n\r\n  function isValidUrl(string) {\r\n    const error = notEmpty(string)\r\n    if (error !== \"\") return error\r\n\r\n    try {\r\n      new URL(string);\r\n    } catch (_) {\r\n      return \"This is not a valid URI\";\r\n    }\r\n    return \"\";\r\n  }\r\n  function isValidDate(date) {\r\n    const error = notEmpty(date)\r\n    if (error !== \"\") return error\r\n\r\n    try {\r\n      var today = new Date()\r\n      today.setHours(0,0,0,0)\r\n      if (today <= new Date(date)) {\r\n        return \"\"\r\n      } else {\r\n        return \"The entered date is in the past\"\r\n      }\r\n    }catch(_) {\r\n      return \"This is not a valid date\"\r\n    }\r\n  }\r\n  function isValidDateInterval(date1, date2) {\r\n    const error = notEmpty(date2)\r\n    if (error !== \"\") return error\r\n\r\n    if (date1 === \"\") {\r\n      return \"The start date should not be empty\"\r\n    }\r\n    if (new Date(date1) <= new Date(date2)) {\r\n      return \"\"\r\n    } else {\r\n      return \"The end date should be after the start date\"\r\n    }\r\n  }\r\n\r\n  function isValidFloat(price) {\r\n    const error = notEmpty(price)\r\n    if (error !== \"\") return error\r\n\r\n    if (parseFloat(price) < 0) {\r\n      return \"Price should be positive\";\r\n    } else if (parseFloat(price) >= 0) {\r\n      return \"\"\r\n    } else {\r\n      return \"Not a valid number\"\r\n    }\r\n  }\r\n  function isValidInt(count) {\r\n    const error = notEmpty(count)\r\n    if (error !== \"\") return error\r\n\r\n    if (parseInt(count) < 0) {\r\n      return \"Count should be positive\";\r\n    } else if (parseFloat(count) >= 0) {\r\n      return \"\"\r\n    } else {\r\n      return \"Not a valid number\"\r\n    }\r\n  }\r\n  function notEmpty(str) {\r\n    if (str === \"\") {\r\n      return \"The field should not be empty\"\r\n    } else {\r\n      return \"\"\r\n    }\r\n  }"]},"metadata":{},"sourceType":"module"}